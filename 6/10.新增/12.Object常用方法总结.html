<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script type="text/javascript">

  // 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
  // var obj = {a:1,b:2};
  // console.log(Object.create(obj));

  // ES6
  // Object.is(obj1, obj2);
  // Object.assign({}, oldObj);

  // obj = {a: 1, b: 2};
  // console.log(Object.keys(obj)); // ["a", "b"] 返回对象的可枚举属性和方法的名称
  // console.log(Object.values(obj)); // [1, 2]
  // console.log(Object.entries(obj)); // [ ["a", 1], ["b", 2] ] 返回一个给定对象自身可枚举属性的键值对数组


  // Object.defineProperty(window, 'a', {
  //   get () {
  //     return this.value++
  //   }
  // });

  // 获取对象下的所有属性，包括不可遍历属性
  // let names = Object.getOwnPropertyNames(obj);

  // for...in循环是 遍历对象可枚举属性,包括原型链上面的可枚举属性；（深复制）
  // 而Object.keys()只是遍历可枚举属性,不可以遍历原型链上的可枚举属性.
  // 而Object.getOwnPropertyNames()则是遍历自身所有属性（不论是否是可枚举的）,不包括原型链上面的.

  function P () {
    this.name = name;
  }
  P.prototype.a = 1;
  let p = new P();
  p.b = 2;
  for (let i in p){
    console.log(i);
  }
  console.log(Object.keys(p));


  // if (obj.hasOwnProperty(key)) { // hasOwnProperty检测某个对象是否拥有某个属性
  // 如果启用ESLint 配置"extends": "eslint:recommended"，则会报错；
  // 新的写法：Object.prototype.hasOwnProperty.call(obj, 'xxx')
  // 参考：https://zhuanlan.zhihu.com/p/118126825

  var obj1 = {
    a: 1,
    b: 2
  };
  var obj2 = {
    a: 1,
    b: 2
  };

  var c = Symbol();
  obj1[c] = 3;
  obj2[c] = 3;
  console.log(obj1, obj2);
  console.log(Object.is(obj1, obj2)); // false，指向的是不同的内存


  var obj3 = obj1;
  var obj4 = obj1;
  console.log(Object.is(obj3, obj4));// true，指向的是相同的内存


  // 遍历可枚举属性  // for in 在循环对象的属性时也会遍历原型链
  for(let key in obj1){
      console.log(key); // a, b
  }

  console.log(obj1.hasOwnProperty(c)); // true hasOwnProperty检测某个对象是否拥有某个属性



</script>
</body>
</html>