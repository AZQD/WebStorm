<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script type="text/javascript">

  // 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
  // var obj = {a:1,b:2};
  // console.log(Object.create(obj));

  // ES6
  // Object.is(obj1, obj2);
  // Object.assign({}, oldObj);

  // obj = {a: 1, b: 2};
  // console.log(Object.keys(obj)); // ["a", "b"] 返回对象的可枚举属性和方法的名称
  // console.log(Object.values(obj)); // [1, 2]
  // console.log(Object.entries(obj)); // [ ["a", 1], ["b", 2] ] 返回一个给定对象自身可枚举属性的键值对数组


  // Object.defineProperty(window, 'a', {
  //   get () {
  //     return this.value++
  //   }
  // });

  // 获取对象下的所有属性，包括不可遍历属性
  // let names = Object.getOwnPropertyNames(obj);

  // Object.getOwnPropertyNames和Object.keys的区别，即Object.keys只适用于可枚举的属性，而Object.getOwnPropertyNames返回对象自动的全部属性名称。


  // if (obj.hasOwnProperty(key)) { // hasOwnProperty检测某个对象是否拥有某个属性

  var obj1 = {
    a: 1,
    b: 2
  };
  var obj2 = {
    a: 1,
    b: 2
  };

  var c = Symbol();
  obj1[c] = 3;
  obj2[c] = 3;
  console.log(obj1, obj2);
  console.log(Object.is(obj1, obj2)); // false，指向的是不同的内存


  var obj3 = obj1;
  var obj4 = obj1;
  console.log(Object.is(obj3, obj4));// true，指向的是相同的内存


  // 遍历不可枚举属性  // for in 在循环对象的属性时也会遍历原型链
  for(let key in obj1){
      console.log(key); // a, b
  }

  console.log(obj1.hasOwnProperty(c)); // true hasOwnProperty检测某个对象是否拥有某个属性



</script>
</body>
</html>