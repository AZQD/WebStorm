<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<input id="fileIpt" type="file" multiple="multiple" onchange="uploadFun()">

<img id="imgFile" alt="">

<script type="text/javascript">

    let fileIpt = document.getElementById("fileIpt");

    // 上传文件操作
    async function uploadFun () {
        // console.log(fileIpt);
        // console.log(fileIpt.value);
        // console.log(fileIpt.files);

        let files = fileIpt.files;
        for (let i = 0; i < files.length; i++) {


            // File源文件
            let file = files[i];
            console.log(`第${i}个file文件为：`, file);
            console.log('%c *******', 'color:red;');


            // file_base64
            let base64 = await file_base64(file);
            console.log(`第${i}个base64文件为：`, base64);
            console.log('%c *******', 'color:red;');


            // base64_blob
            let blob = base64_blob(base64);
            console.log(`第${i}个blob文件为：`, blob);

            let blobURL = window.URL.createObjectURL(blob); // Blob URL所实现的下载或者显示等功能，仅仅可以在单个浏览器内部进行
            console.log(`第${i}个blobURL文件为：`, blobURL);
            document.getElementById("imgFile").setAttribute('src', blobURL);

            document.getElementById("imgFile").onload = function () {
                // 释放一个之前通过调用 URL.createObjectURL创建的 URL 对象
                // window.URL.revokeObjectURL(blobURL);
                // console.log(`第${i}个blobURL被释放了：`, blobURL);
            };
            console.log('%c *******', 'color:red;');


            // blob_arrayBuffer
            let arrayBuffer = await blob_arrayBuffer(blob);
            console.log(`第${i}个arrayBuffer文件为：`, arrayBuffer);
            console.log('%c *******', 'color:red;');


            // base64_file
            let newFile = base64_file(base64, file.name.split('.')[0]);
            console.log(`第${i}个base64文件转为新的file文件为：`, newFile);
            console.log('%c *******', 'color:red;');
        }
    }


    // file 转 base64
    function file_base64 (file) {
        return new Promise(((resolve, reject) => {
            let reader = new FileReader();
            reader.readAsDataURL(file);
            reader.addEventListener("load", function () {
                resolve(reader.result);
            }, false);
            reader.addEventListener('error', reject); // don't forget this one
        }));
    }


    // base64 转 file
    function base64_file (base64, filename) { // 64转file
        if (typeof base64 !== 'string') {
            alert("urlData不是字符串");
            return;
        }
        let arr = base64.split(',');
        let type = arr[0].match(/:(.*?);/)[1];
        let fileExt = type.split('/')[1];
        let bstr = atob(arr[1]);
        let n = bstr.length;
        let u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new File([u8arr], `${filename}.` + fileExt, {
            type: type
        });
    }


    // base64 转 blob
    function base64_blob (base64) {
        let byteString = atob(base64.split(',')[1]);
        let mimeString = base64.split(',')[0].split(':')[1].split(';')[0];
        let ab = new ArrayBuffer(byteString.length);
        let ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ab], {type: mimeString});
    }


    // blob 转 ArrayBuffer
    function blob_arrayBuffer (blob) {
        return new Promise(((resolve, reject) => {
            let blobData = new Blob([blob]);
            let reader = new FileReader();
            reader.readAsArrayBuffer(blobData);
            reader.addEventListener("load", function () {
                resolve(reader.result);
            }, false);
            reader.addEventListener('error', reject); // don't forget this one
        }));
    }


</script>
</body>
</html>